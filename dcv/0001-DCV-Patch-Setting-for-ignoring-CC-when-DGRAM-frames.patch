From 8f4b2ea9320a255068a52f5689ef31264c23a797 Mon Sep 17 00:00:00 2001
From: BiagioFesta <15035284+BiagioFesta@users.noreply.github.com>
Date: Mon, 28 Aug 2023 12:22:24 +0200
Subject: [PATCH] DCV Patch: Setting for ignoring CC when DGRAM frames

---
 quiche/include/quiche.h |  3 +++
 quiche/src/ffi.rs       |  5 +++++
 quiche/src/lib.rs       | 44 ++++++++++++++++++++++++++++++++---------
 3 files changed, 43 insertions(+), 9 deletions(-)

diff --git a/quiche/include/quiche.h b/quiche/include/quiche.h
index c0d1406b..1d5120ec 100644
--- a/quiche/include/quiche.h
+++ b/quiche/include/quiche.h
@@ -239,6 +239,9 @@ void quiche_config_enable_dgram(quiche_config *config, bool enabled,
                                 size_t recv_queue_len,
                                 size_t send_queue_len);
 
+// Configure whether DATAGRAMS should ignore congestion control or not.
+void quiche_config_enable_dgram_ignore_cc(quiche_config *config, bool v);
+
 // Sets the maximum connection window.
 void quiche_config_set_max_connection_window(quiche_config *config, uint64_t v);
 
diff --git a/quiche/src/ffi.rs b/quiche/src/ffi.rs
index 0183730d..68e044dc 100644
--- a/quiche/src/ffi.rs
+++ b/quiche/src/ffi.rs
@@ -354,6 +354,11 @@ pub extern fn quiche_config_enable_dgram(
     config.enable_dgram(enabled, recv_queue_len, send_queue_len);
 }
 
+#[no_mangle]
+pub extern fn quiche_config_enable_dgram_ignore_cc(config: &mut Config, v: bool) {
+    config.enable_dgram_ignore_cc(v)
+}
+
 #[no_mangle]
 pub extern fn quiche_config_set_max_send_udp_payload_size(
     config: &mut Config, v: size_t,
diff --git a/quiche/src/lib.rs b/quiche/src/lib.rs
index 91178125..b9132921 100644
--- a/quiche/src/lib.rs
+++ b/quiche/src/lib.rs
@@ -712,6 +712,7 @@ pub struct Config {
 
     cc_algorithm: CongestionControlAlgorithm,
     initial_congestion_window_packets: usize,
+    dgram_ignore_cc: bool,
 
     hystart: bool,
 
@@ -778,6 +779,7 @@ impl Config {
             cc_algorithm: CongestionControlAlgorithm::CUBIC,
             initial_congestion_window_packets:
                 DEFAULT_INITIAL_CONGESTION_WINDOW_PACKETS,
+            dgram_ignore_cc: false,
             hystart: true,
             pacing: true,
             max_pacing_rate: None,
@@ -1202,6 +1204,18 @@ impl Config {
         self.dgram_send_max_queue_len = send_queue_len;
     }
 
+    /// Configure whether datagrams should ignore congestion controll or not.
+    /// When this flag is enabled (`true`), the effects are:
+    ///    * Packets containg datagram frames are not bounded by CWND (i.e.,
+    ///      window congestion control).
+    ///    * Datagram frames are marked as `NOT ack eliciting` and `NOT in
+    ///      flight`.
+    ///
+    /// The default value is `false`.
+    pub fn enable_dgram_ignore_cc(&mut self, v: bool) {
+        self.dgram_ignore_cc = v
+    }
+
     /// Configures the max number of queued received PATH_CHALLENGE frames.
     ///
     /// When an endpoint receives a PATH_CHALLENGE frame and the queue is full,
@@ -1441,6 +1455,9 @@ pub struct Connection {
     dgram_recv_queue: dgram::DatagramQueue,
     dgram_send_queue: dgram::DatagramQueue,
 
+    /// Whether DATAGRAMS ignore congestion control.
+    dgram_ignore_cc: bool,
+
     /// Whether to emit DATAGRAM frames in the next packet.
     emit_dgram: bool,
 
@@ -1899,6 +1916,8 @@ impl Connection {
                 config.dgram_send_max_queue_len,
             ),
 
+            dgram_ignore_cc: config.dgram_ignore_cc,
+
             emit_dgram: true,
 
             disable_dcid_reuse: config.disable_dcid_reuse,
@@ -3426,7 +3445,11 @@ impl Connection {
             }
         }
 
-        let is_app_limited = self.delivery_rate_check_if_app_limited();
+        let ignore_cc =
+            self.dgram_ignore_cc && self.dgram_send_queue.has_pending();
+
+        let is_app_limited =
+            !ignore_cc && self.delivery_rate_check_if_app_limited();
         let n_paths = self.paths.len();
         let path = self.paths.get_mut(send_pid)?;
         let flow_control = &mut self.flow_control;
@@ -3600,12 +3623,15 @@ impl Connection {
             }
         }
 
-        // Limit output packet size by congestion window size.
-        left = cmp::min(
-            left,
-            // Bytes consumed by ACK frames.
-            cwnd_available.saturating_sub(left_before_packing_ack_frame - left),
-        );
+        if !ignore_cc {
+            // Limit output packet size by congestion window size.
+            left = cmp::min(
+                left,
+                // Bytes consumed by ACK frames.
+                cwnd_available
+                    .saturating_sub(left_before_packing_ack_frame - left),
+            );
+        }
 
         let mut challenge_data = None;
 
@@ -4047,8 +4073,8 @@ impl Connection {
                                     frame::Frame::DatagramHeader { length: len };
 
                                 if push_frame_to_pkt!(b, frames, frame, left) {
-                                    ack_eliciting = true;
-                                    in_flight = true;
+                                    ack_eliciting = !self.dgram_ignore_cc;
+                                    in_flight = !self.dgram_ignore_cc;
                                     dgram_emitted = true;
                                 }
                             },
-- 
2.43.0

